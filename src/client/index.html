<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Life simulation</title>

		<script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js"></script>
		<script type="text/javascript" charset="utf-8">
			// init connection and retrieve main map
			var BASE_URL = 'http://127.0.0.1:10001/';
			var socket = io.connect(BASE_URL);
			socket.on('connect', function(data) {
				socket.emit('message', {counter: 1})

				socket.on('message', function(data){
					console.log(data);
				});
			});
		</script>

		<style type="text/css">
			* {
				margin: 0;
				padding: 0;
				overflow: hidden;
			}
		</style>

	</head>

	<body>
		<!-- <p>Hello world</p> -->
		<canvas id="canvas"></canvas>
	</body>

	<script type="text/javascript">
		// retrieve main map

		function makeRequest(endpoint, params){
			let paramsString = '';
			for(var i in params){
				if(paramsString == '')
					paramsString += '?';

				paramsString += i + '=' + String(params[i]) + '&';
			}
			var xhr = new XMLHttpRequest();
			xhr.open('GET', BASE_URL + endpoint + paramsString, false)
			xhr.send();
			return JSON.parse(xhr.responseText);
		}

		// init canvas
		var canvas = document.getElementById('canvas');
		var ctx = canvas.getContext('2d');
		var w = canvas.width = window.innerWidth;
		var h = canvas.height = window.innerHeight;

		var cellSize = 10;

		var additionalAreaFactor = 1.5; // this value need for user can easily move camera(without delay)
		var needCellsSize = {
			'x': Math.round(w / cellSize * additionalAreaFactor),
			'y': Math.round(h / cellSize * additionalAreaFactor),
			'raw_x': Math.round(w / cellSize),
			'raw_y': Math.round(h / cellSize),
			'offset_x': 0,
			'offset_y': 0
		}
		console.log(needCellsSize)

		var mainWorld = makeRequest('get_world', needCellsSize);
		var colorPalette = makeRequest('get_settings', {});

		var CAMERA_OFFSET = {
			x: 0,
			y: 0
		}

		var keys = [];
		window.addEventListener("keydown",
			function(e){
				keys[e.keyCode] = true;
				checkCombinations();
				// console.log(keys)
			},
		false);

		window.addEventListener('keyup',
			function(e){
				keys[e.keyCode] = false;
			},
		false);
		// document.addEventListener("keypress", function(event) {
		function checkCombinations(){
			if(65 in keys && keys[65] == true){
				// keycode "a"
				if(CAMERA_OFFSET.x > 0)
					CAMERA_OFFSET.x -= 1;
			}
			if (68 in keys && keys[68] == true) {
				// keycode "d"
				CAMERA_OFFSET.x += 1;
			}
			if (87 in keys && keys[87] == true) {
				// keycode "w"
				if (CAMERA_OFFSET.y > 0)
					CAMERA_OFFSET.y -= 1;
			}
			if (83 in keys && keys[83] == true) {
				// keycode "s"
				CAMERA_OFFSET.y += 1;
			}
		}

		function componentToHex(c) {
			var hex = c.toString(16);
			return hex.length == 1 ? "0" + hex : hex;
		}

		function rgbToHex(rgb) {
			return "#" + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);
		}

		function drawWorld(){
			ctx.clearRect(0,0, w,h); // clear surface
			// draw world
			for(var y in mainWorld.slice(CAMERA_OFFSET.y, CAMERA_OFFSET.y + needCellsSize.raw_y)){
				for(var x in mainWorld[y].slice(CAMERA_OFFSET.x, CAMERA_OFFSET.x + needCellsSize.raw_x)){
					ctx.beginPath();
					ctx.rect(
						(x) * cellSize,
						(y) * cellSize,
						cellSize,
						cellSize
					);
					let blockName = colorPalette['BLOCKS']['INDEX_BLOCKS'][mainWorld[Number(y) + CAMERA_OFFSET.y][Number(x) + CAMERA_OFFSET.x]];
					
					let blockColor = rgbToHex(colorPalette['BLOCKS'][blockName]);

					ctx.fillStyle = blockColor;
					ctx.fill();
				}
			}
			// console.log(CAMERA_OFFSET)
			// console.log(mainWorld.slice(CAMERA_OFFSET.y, CAMERA_OFFSET.y + needCellsSize.raw_y).length)

			// draw grid
			let lineWidth = 0.4;
			for (y = 0; y <= h; y++) {
				ctx.beginPath();
				ctx.moveTo(y * cellSize, 0);
				ctx.lineTo(y * cellSize, h);
				ctx.lineWidth = lineWidth;
				ctx.stroke();
			}
			for (x = 0; x <= w; x++) {
				ctx.beginPath();
				ctx.moveTo(0, x * cellSize);
				ctx.lineTo(w, x * cellSize);
				ctx.lineWidth = lineWidth;
				ctx.stroke();
			}
		}

		function loop(){
			drawWorld();
		}

		// loop();
		setInterval(function(){loop();}, 16);

	</script>


</html>